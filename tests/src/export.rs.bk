#![feature(proc_macro)]

use mock_derive::mock;

//#[mock]
// trait ExportTrait {
//     fn export(&mut self) -> i32;
// }


trait ExportTrait { fn export ( & mut self ) -> i32 ; } # [ allow ( dead_code ) ] struct MockExportTrait { fallback : Option < Box < ExportTrait >> , export : Option < MockMethodForExportTrait < i32 >> , } # [ allow ( dead_code ) ] # [ allow ( non_camel_case_types ) ] struct MockMethodForExportTrait < __RESULT_NAME > { call_num : :: std :: sync :: Mutex < usize > , current_num : :: std :: sync :: Mutex < usize > , retval : :: std :: sync :: Mutex < :: std :: collections :: HashMap < usize , __RESULT_NAME >> , lambda : Option < Box < Fn ( ) -> __RESULT_NAME >> , } # [ allow ( dead_code ) ] impl MockExportTrait { pub fn method_export ( & self ) -> MockMethodForExportTrait < i32 > { MockMethodForExportTrait { call_num : :: std :: sync :: Mutex :: new ( 1 ) , current_num : :: std :: sync :: Mutex :: new ( 1 ) , retval : :: std :: sync :: Mutex :: new ( :: std :: collections :: HashMap :: new ( ) ) , lambda : None , } } pub fn set_export ( & mut self , method : MockMethodForExportTrait < i32 > ) { self . export = Some ( method ) ; } pub fn new ( ) -> MockExportTrait { MockExportTrait { fallback : None , export : None , } } # [ allow ( non_camel_case_types ) ] pub fn set_fallback < __TYPE_NAME : 'static + ExportTrait > ( & mut self , t : __TYPE_NAME ) { self . fallback = Some ( Box :: new ( t ) ) ; } } # [ allow ( dead_code ) ] # [ allow ( non_camel_case_types ) ] impl < __RESULT_NAME > MockMethodForExportTrait < __RESULT_NAME > { pub fn first_call ( self ) -> Self { self . nth_call ( 1 ) } pub fn second_call ( self ) -> Self { self . nth_call ( 2 ) } pub fn nth_call ( self , num : usize ) -> Self { { let mut value = self . call_num . lock ( ) . unwrap ( ) ; * value = num ; } self } pub fn set_result ( self , retval : __RESULT_NAME ) -> Self { if self . lambda . is_some ( ) { panic ! ( "Attempting to call set_result with after 'return_result_of' has been called. These two APIs are mutally exclusive, and should not be used together" ) ; } { let call_num = self . call_num . lock ( ) . unwrap ( ) ; let mut map = self . retval . lock ( ) . unwrap ( ) ; map . insert ( * call_num , retval ) ; } self } pub fn call ( & self ) -> Option < __RESULT_NAME > { match self . lambda { Some ( ref lm ) => { Some ( lm ( ) ) } , None => { let mut value = self . current_num . lock ( ) . unwrap ( ) ; let current_num = * value ; * value += 1 ; let mut map = self . retval . lock ( ) . unwrap ( ) ; map . remove ( & current_num ) } } } pub fn return_result_of < F : 'static > ( mut self , lambda : F ) -> Self where F : Fn ( ) -> __RESULT_NAME { self . lambda = Some ( Box :: new ( lambda ) ) ; self } } impl ExportTrait for MockExportTrait { fn export ( & mut self ) -> i32 { match self . export . as_ref ( ) { Some ( method ) => { match method . call ( ) { Some ( retval ) => { retval } , None => { let ref fallback = self . fallback . as_mut ( ) . expect ( "Called method without either a fallback, or a set result" ) ; fallback . export ( ) } } } , None => { let ref fallback = self . fallback . as_mut ( ) . expect ( "Called method without either a fallback, or a set result" ) ; fallback . export ( ) } } } }                                                                    
